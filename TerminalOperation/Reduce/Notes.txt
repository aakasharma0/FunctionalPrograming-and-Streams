===============================
REDUCE (BinaryOperator version)
===============================

Method form:
-------------
Optional<T> reduce(BinaryOperator<T> accumulator)

Example:
--------
Optional<Integer> result =
    list.stream().reduce((x, y) -> x + y);

What it does:
-------------
- Takes TWO elements from the stream at a time
- Combines them into ONE element
- Repeats until a single result remains

Type rules:
-----------
- Input type = T
- Output type = T
- Both operands and result MUST be the same type
- Thatâ€™s why it uses BinaryOperator<T>

Execution (sequential example):
-------------------------------
Stream: [1, 2, 3, 4]

Step 1: (1, 2) -> 3
Step 2: (3, 3) -> 6
Step 3: (6, 4) -> 10

Final result = 10

Why return type is Optional<T>:
-------------------------------
- This reduce version has NO identity value
- If the stream is EMPTY, there is no result
- To avoid returning null, Java returns Optional<T>

Empty stream case:
------------------
List<Integer> list = List.of();

list.stream().reduce((x, y) -> x + y);
// Result: Optional.empty()

Important rules (VERY IMPORTANT):
--------------------------------
1) Accumulator MUST be associative
   (a op b) op c == a op (b op c)

   Good: addition, multiplication
   Bad: subtraction, division (unsafe in parallel)

2) Accumulator MUST be stateless
   - No external mutable state
   - No side effects

3) Reduce is for IMMUTABLE reduction
   - Do NOT modify collections inside reduce

What this reduce is GOOD for:
-----------------------------
- Sum
- Min / Max
- Product
- Any same-type aggregation

What this reduce CANNOT do:
---------------------------
- Change data type
- Accumulate into mutable objects (List, Map)
- Handle empty streams without Optional

Mental model (one line):
-----------------------
"Reduce with BinaryOperator combines stream elements of the same type into a single result."

Interview one-liner:
--------------------
"This form of reduce takes a BinaryOperator that combines two elements of the same type and returns an Optional because the stream may be empty."



=================================
ACCUMULATOR & IDENTITY (CORE IDEA)
=================================

Example:
--------
int sum = 0;            // identity
for (int num : nums) {
    sum = sum + num;    // accumulator
}

What is Identity?
-----------------
- Identity is the starting value.
- It is a neutral value for the operation.
- It does NOT change the result.

In this example:
----------------
identity = 0

Reason:
-------
0 + x = x
So starting from 0 does not affect the final sum.

What is Accumulator?
--------------------
- Accumulator is the logic that combines:
  1) the current accumulated result
  2) the next incoming value
- It produces a new accumulated result.

In this example:
----------------
accumulator logic = sum = sum + num

Meaning:
--------
- sum = previous result
- num = new value
- sum + num = updated result

How accumulation works step-by-step:
------------------------------------
nums = [1, 2, 3]

start: sum = 0
step1: sum = 0 + 1 = 1
step2: sum = 1 + 2 = 3
step3: sum = 3 + 3 = 6

Final result:
-------------
sum = 6

Key Concept (Very Important):
-----------------------------
- Identity = starting point
- Accumulator = rule that updates the running result
- Final accumulated value = result

One-line summary:
-----------------
Identity provides the initial value, and the accumulator repeatedly combines the previous result with the next value to produce the final result.


In reduce(BinaryOperator), the first stream element acts as the initial accumulated value.


int[] nums = {1, 2, 3, 4, 5, 6};

/* Imagine work is split into two parts */

// ----- Part 1 (accumulation) -----
int sum1 = 0;                 // identity
for (int i = 0; i < 3; i++) { // [1,2,3]
    sum1 = sum1 + nums[i];    // accumulator
}

// ----- Part 2 (accumulation) -----
int sum2 = 0;                 // identity
for (int i = 3; i < 6; i++) { // [4,5,6]
    sum2 = sum2 + nums[i];    // accumulator
}

// ----- Combine partial results -----
int finalSum = sum1 + sum2;   // combiner

System.out.println(finalSum); // 21


the combiner in reduce is only invoked when partial results need to be merged, typically in parallel streams.